import 'dart:async';

import 'package:async_redux/async_redux.dart';
import 'package:flutter/widgets.dart';
import 'app_state.dart';

/// To access the state inside of widgets, you can use `StoreProvider.of`. For example:
///
/// ```
/// // Read state
/// var myInfo = StoreProvider.state<AppState>(context).myInfo;
///
/// // Dispatch action
/// StoreProvider.dispatch<AppState>(context, MyAction());
/// ```
///
/// However, this extension allows you to write the above code like this:
///
/// ```
/// // Read state
/// var myInfo = context.state.myInfo;
///
/// // Dispatch action
/// context.dispatch(MyAction());
/// ```
extension BuildContextExtension on BuildContext {
  //

  /// You can access the store state from inside your widgets, using the context:
  /// ```
  /// context.state.myInfo;
  /// ```
  AppState get state => StoreProvider.state<AppState>(this);

  /// Runs the action, applying its reducer, and possibly changing the store state.
  /// The action may be sync or async. Note: [dispatch] is of type [Dispatch].
  ///
  /// Use it like this:
  /// ```
  /// context.dispatch(MyAction());
  /// ```
  FutureOr<ActionStatus> dispatch(ReduxAction<AppState> action, {bool notify = true}) => StoreProvider.dispatch(this, action, notify: notify);

  /// Runs the action, applying its reducer, and possibly changing the store state.
  /// Note: [dispatchAndWait] is of type [DispatchAndWait]. It returns `Future<ActionStatus>`,
  /// which means you can `await` it.
  ///
  /// Use it like this:
  /// ```
  /// context.dispatchAndWait(MyAction());
  /// ```
  Future<ActionStatus> dispatchAndWait(ReduxAction<AppState> action, {bool notify = true}) => StoreProvider.dispatchAndWait(this, action, notify: notify);

  /// Runs the action, applying its reducer, and possibly changing the store state.
  /// Note: [dispatchSync] is of type [DispatchSync].
  /// If the action is async, it will throw a [StoreException].
  ///
  /// Use it like this:
  /// ```
  /// context.dispatchSync(MySyncAction());
  /// ```
  ActionStatus dispatchSync(ReduxAction<AppState> action, {bool notify = true}) => StoreProvider.dispatchSync(this, action, notify: notify);

  /// You can use [isWaitingFor] to check if:
  /// * A specific async ACTION is currently being processed.
  /// * An async action of a specific TYPE is currently being processed.
  /// * If any of a few given async actions or action types is currently being processed.
  ///
  /// If you wait for an action TYPE, then it returns false when:
  /// - The ASYNC action of type [actionType] is NOT currently being processed.
  /// - If [actionType] is not really a type that extends [ReduxAction].
  /// - The action of type [actionType] is a SYNC action (since those finish immediately).
  ///
  /// If you wait for an ACTION, then it returns false when:
  /// - The ASYNC [action] is NOT currently being processed.
  /// - If [action] is a SYNC action (since those finish immediately).
  //
  /// Examples:
  ///
  /// ```dart
  /// // Waiting for an action TYPE:
  /// dispatch(MyAction());
  /// if (store.isWaitingFor(MyAction)) { // Show a spinner }
  ///
  /// // Waiting for an ACTION:
  /// var action = MyAction();
  /// dispatch(action);
  /// if (store.isWaitingFor(action)) { // Show a spinner }
  ///
  /// // Waiting for any of the given action TYPES:
  /// dispatch(BuyAction());
  /// if (store.isWaitingFor([BuyAction, SellAction])) { // Show a spinner }
  /// ```
  bool isWaitingFor(Object actionOrTypeOrList) => StoreProvider.isWaitingFor<AppState>(this, actionOrTypeOrList);
}
